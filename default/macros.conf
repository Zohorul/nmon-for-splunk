
#########################################
#	LPAR Specific definitions
#########################################

[lpar_define_conso]
definition = eval lpar_ecconso=round(((EC_User_PCT+EC_Sys_PCT+EC_Wait_PCT+EC_Idle_PCT)*entitled/100),2)\
| eval lpar_ec_pct_conso=round((((EC_User_PCT+EC_Sys_PCT+EC_Wait_PCT+EC_Idle_PCT)*entitled)/virtualCPUs),2)\
| eval lpar_vpconso=round(((VP_User_PCT+VP_Sys_PCT+VP_Wait_PCT+VP_Idle_PCT)*virtualCPUs/100),2)\
| eval lpar_vp_pct_conso=round((VP_User_PCT+VP_Sys_PCT+VP_Wait_PCT+VP_Idle_PCT),2)\
| eval pool_conso=round((poolCPUs-PoolIdle),2)\
| eval pool_pct_conso=round(((poolCPUs-PoolIdle)*poolCPUs/100),2)
iseval = 0


#########################################
#	Custom Span Macro Definition
#########################################

# Since Version 1.4.4 of Nmon App, the custom span definition has been improved to match at the lower level the nmon interval definition now incorporated in the data indexed by Splunk
# The converter adds this data in fields "interval"
# If the field is not present in data (eg. data indexed before Version 1.4.4), then the standard span time will be applied
# So, ONLY if you indexed Nmon data prior to Version 1.4.4:

# If your minimal interval data is higher (for example your minimal interval data is 5 minutes between 2 measures), then you should customized
# the macro in your local/macros.conf file
# An commented example with 5 minutes data interval is provided after the 2 standard macros used within the App 
# This will allow data indexed before Version 1.4.4 to have an adapted span definition
# It is not required if you don't have data indexed with version prior to 1.4.4 (and Python converter version prior to 1.0.4)

# The macro behind assumes that your interval between 2 measures will never be lower than 1 hour, which is a very very minimal configuration !
# If not, then you have to customize the macro on own

# The macro requires 2 arguments, the type (type of performance monitor) and hostname, both arguments can be multiple
# If multiple hostname are provided, we will assume they share the same interval value as we keep only the 1st result for performance purpose
# If multiple type are provided, they anyway always share the same interval value

#################
# CUSTOMIZATION:
#################

# If you want to set a minimal span feature that better fits your data, such as 5mn between 2 mesures for example, please:
# - Copy the 2 customspan macros to your local/macros.conf
# - Edit the line:

#
# For [inline_customspan(2)]
#

#  | eval span=if(spanrestricted <= 20, "20s", span)\

# And replace with: (example with 5 minutes span, time unit is in seconds)

#  | eval span=if(spanrestricted <= (5*60), "5m", span)\

#
# For [inline_customspan_django(2)] (note: No '\' at end of line)
#

# | eval span=if(spanrestricted <= 20, "20s", span)

# And replace with:

# | eval span=if(spanrestricted <= 20, "20s", span)


[inline_customspan(2)]
args = type,hostname
definition = [ search index="nmon" sourcetype="nmon_data" $type$ $hostname$ | head 1 | addinfo\
| eval earliest=if(info_min_time == "0.000", info_search_time,info_min_time)\
| eval latest=if(info_max_time == "+Infinity", info_search_time,info_max_time)\
| eval searchStartTIme=strftime(earliest,"%a %d %B %Y %H:%M")\
| eval searchEndTime=strftime(latest,"%a %d %B %Y %H:%M")\
| eval Difference = (latest - earliest)\
| eval span=case(\
info_min_time == "0.000", "2m",\
Difference > (3000*24*60*60),"4d",\
Difference > (2000*24*60*60),"3d",\
Difference > (1000*24*60*60),"2d",\
Difference > (500*24*60*60),"1d",\
Difference > (333*24*60*60),"12h",\
Difference > (166*24*60*60),"8h",\
Difference > (83*24*60*60),"4h",\
Difference > (41*24*60*60),"2h",\
Difference > (916*60*60),"1h",\
Difference > (833*60*60),"55m",\
Difference > (750*60*60),"50m",\
Difference > (666*60*60),"45m",\
Difference > (583*60*60),"40m",\
Difference > (500*60*60),"35m",\
Difference > (416*60*60),"30m",\
Difference > (333*60*60),"25m",\
Difference > (250*60*60),"20m",\
Difference > (166*60*60),"15m",\
Difference > (83*60*60),"10m",\
Difference > (66*60*60),"5m",\
Difference > (50*60*60),"4m",\
Difference > (33*60*60),"3m",\
Difference > (16*60*60),"2m",\
Difference > (8*60*60),"1m",\
Difference > (2*60*60),"30s",\
Difference <= (2*60*60),"20s"\
)\
| eval spanrestricted=case(\
info_min_time == "0.000", 2*60,\
Difference > (916*60*60),60*60,\
Difference > (833*60*60),55*60,\
Difference > (750*60*60),50*60,\
Difference > (666*60*60),45*60,\
Difference > (583*60*60),40*60,\
Difference > (500*60*60),35*60,\
Difference > (416*60*60),30*60,\
Difference > (333*60*60),25*60,\
Difference > (250*60*60),20*60,\
Difference > (166*60*60),15*60,\
Difference > (83*60*60),10*60,\
Difference > (66*60*60),5*60,\
Difference > (50*60*60),4*60,\
Difference > (33*60*60),180,\
Difference > (16*60*60),120,\
Difference > (8*60*60),60,\
Difference > (2*60*60),30,\
Difference <= (2*60*60),20\
)\
| eval span=case(spanrestricted < interval, interval, spanrestricted >= interval, span, isnull(interval), span)\
| eval span=if(spanrestricted <= 20, "20s", span)\
| return span ]
iseval = 0

# Data model version

[inline_customspan(3)]
args = type,earliest,latest
definition = [ search index="nmon" sourcetype="nmon_data" earliest=$earliest$ latest=$latest$ $type$ | head 1 | addinfo\
| eval earliest=if(info_min_time == "0.000", info_search_time,info_min_time)\
| eval latest=if(info_max_time == "+Infinity", info_search_time,info_max_time)\
| eval searchStartTIme=strftime(earliest,"%a %d %B %Y %H:%M")\
| eval searchEndTime=strftime(latest,"%a %d %B %Y %H:%M")\
| eval Difference = (latest - earliest)\
| eval span=case(\
info_min_time == "0.000", "2m",\
Difference > (3000*24*60*60),"4d",\
Difference > (2000*24*60*60),"3d",\
Difference > (1000*24*60*60),"2d",\
Difference > (500*24*60*60),"1d",\
Difference > (333*24*60*60),"12h",\
Difference > (166*24*60*60),"8h",\
Difference > (83*24*60*60),"4h",\
Difference > (41*24*60*60),"2h",\
Difference > (916*60*60),"1h",\
Difference > (833*60*60),"55m",\
Difference > (750*60*60),"50m",\
Difference > (666*60*60),"45m",\
Difference > (583*60*60),"40m",\
Difference > (500*60*60),"35m",\
Difference > (416*60*60),"30m",\
Difference > (333*60*60),"25m",\
Difference > (250*60*60),"20m",\
Difference > (166*60*60),"15m",\
Difference > (83*60*60),"10m",\
Difference > (66*60*60),"5m",\
Difference > (50*60*60),"4m",\
Difference > (33*60*60),"3m",\
Difference > (16*60*60),"2m",\
Difference > (8*60*60),"1m",\
Difference > (2*60*60),"30s",\
Difference <= (2*60*60),"20s"\
)\
| eval spanrestricted=case(\
info_min_time == "0.000", 2*60,\
Difference > (916*60*60),60*60,\
Difference > (833*60*60),55*60,\
Difference > (750*60*60),50*60,\
Difference > (666*60*60),45*60,\
Difference > (583*60*60),40*60,\
Difference > (500*60*60),35*60,\
Difference > (416*60*60),30*60,\
Difference > (333*60*60),25*60,\
Difference > (250*60*60),20*60,\
Difference > (166*60*60),15*60,\
Difference > (83*60*60),10*60,\
Difference > (66*60*60),5*60,\
Difference > (50*60*60),4*60,\
Difference > (33*60*60),180,\
Difference > (16*60*60),120,\
Difference > (8*60*60),60,\
Difference > (2*60*60),30,\
Difference <= (2*60*60),20\
)\
| eval span=case(spanrestricted < interval, interval, spanrestricted >= interval, span, isnull(interval), span)\
| eval span=if(spanrestricted <= 20, "20s", span)\
| return span ]
iseval = 0

# Inline version used in django views

[inline_customspan_django(2)]
args = type,hostname
definition = head 1 | addinfo\
| eval earliest=if(info_min_time == "0.000", info_search_time,info_min_time)\
| eval latest=if(info_max_time == "+Infinity", info_search_time,info_max_time)\
| eval searchStartTIme=strftime(earliest,"%a %d %B %Y %H:%M")\
| eval searchEndTime=strftime(latest,"%a %d %B %Y %H:%M")\
| eval Difference = (latest - earliest)\
| eval span=case(\
info_min_time == "0.000", "2m",\
Difference > (3000*24*60*60),"4d",\
Difference > (2000*24*60*60),"3d",\
Difference > (1000*24*60*60),"2d",\
Difference > (500*24*60*60),"1d",\
Difference > (333*24*60*60),"12h",\
Difference > (166*24*60*60),"8h",\
Difference > (83*24*60*60),"4h",\
Difference > (41*24*60*60),"2h",\
Difference > (916*60*60),"1h",\
Difference > (833*60*60),"55m",\
Difference > (750*60*60),"50m",\
Difference > (666*60*60),"45m",\
Difference > (583*60*60),"40m",\
Difference > (500*60*60),"35m",\
Difference > (416*60*60),"30m",\
Difference > (333*60*60),"25m",\
Difference > (250*60*60),"20m",\
Difference > (166*60*60),"15m",\
Difference > (83*60*60),"10m",\
Difference > (66*60*60),"5m",\
Difference > (50*60*60),"4m",\
Difference > (33*60*60),"3m",\
Difference > (16*60*60),"2m",\
Difference > (8*60*60),"1m",\
Difference > (2*60*60),"30s",\
Difference <= (2*60*60),"20s"\
)\
| eval spanrestricted=case(\
info_min_time == "0.000", 2*60,\
Difference > (916*60*60),60*60,\
Difference > (833*60*60),55*60,\
Difference > (750*60*60),50*60,\
Difference > (666*60*60),45*60,\
Difference > (583*60*60),40*60,\
Difference > (500*60*60),35*60,\
Difference > (416*60*60),30*60,\
Difference > (333*60*60),25*60,\
Difference > (250*60*60),20*60,\
Difference > (166*60*60),15*60,\
Difference > (83*60*60),10*60,\
Difference > (66*60*60),5*60,\
Difference > (50*60*60),4*60,\
Difference > (33*60*60),180,\
Difference > (16*60*60),120,\
Difference > (8*60*60),60,\
Difference > (2*60*60),30,\
Difference <= (2*60*60),20\
)\
| eval span=case(spanrestricted < interval, interval, spanrestricted >= interval, span, isnull(interval), span)\
| eval span=if(spanrestricted <= 20, "20s", span)
iseval = 0


###############################################
#	Macro used in Compare interface
###############################################

[eval_compare]
definition = eval Evolution_usage=((usage_period2-usage_period1)/usage_period1)*100 | eval Evolution_usage=round(Evolution_usage,2)\
| eval Delta_usage=round((usage_period2-usage_period1),2)\
| eval Evolution_pct_usage=case(isnotnull(pct_usage_period1), ((pct_usage_period2-pct_usage_period1)/pct_usage_period1)*100 ) | eval Evolution_pct_usage=round(Evolution_pct_usage,2)\
| eval Delta_pct_usage=round((pct_usage_period2-pct_usage_period1),2)\
| fields hostname,usage_period1,usage_period2,Delta_usage,Evolution_usage,*\
| rename Evolution_usage As "Evolution_usage (%)"\
| rename Evolution_pct_usage As "Evolution_pct_usage (%)"\
| eval range=case(\
usage_period1==usage_period2, 0, usage_period1<usage_period2, 2, usage_period1>usage_period2, 4,\
pct_usage_period1==pct_usage_period2, 0, pct_usage_period1<pct_usage_period2, 2, pct_usage_period1>pct_usage_period2, 4)\
| rangemap field=range equal=0-1 increase=2-3 decrease=4-5 default=no\
| eval usage_period1=round(usage_period1,2)\
| eval usage_period2=round(usage_period2,2)
iseval = 0


###############################################
#	TimeRange overwrite
###############################################

# Manipulate the given timerange to force earliest and latest to be full days

[timerange_overwrite(2)]
args = indexvalue,sourcetypevalue
definition = [ search index=$indexvalue$ sourcetype=$sourcetypevalue$ | head 1 | addinfo\
| eval earliest=relative_time(info_min_time, "@d")\
| eval latest=relative_time(info_max_time, "+1d@d") | return earliest,latest ]
iseval = 0


###################################
# 	Index Statistics
###################################

[indexes_datestats]

definition = metadata type=sourcetypes index="nmon" | setfields index="nmon" | eval "First Event"=strftime(firstTime,"%d/%m/%Y %H:%M") | eval "Last Event"=strftime(lastTime,"%d/%m/%Y %H:%M") | fields index,sourcetype,*Event
iseval = 0

###################################
# 	Eval Memory
###################################

[MEM_eval]
definition = eval Real_used_MB=round((Real_total_MB-Real_free_MB),1)\
| eval Virtual_total_MB=round((Virtual_total_MB),1)\
| eval Virtual_used_MB=round((Virtual_total_MB-Virtual_free_MB),1)\
| eval memused=round((memtotal-memfree),1)\
| eval swapused=round((swaptotal-swapfree),1)\
| eval Real_used_PCT=round(((Real_used_MB/Real_total_MB)*100),1)\
| eval Virtual_used_PCT=round(((Virtual_used_MB/Virtual_total_MB)*100),1)\
| eval memfree_PCT=round(((memfree/memtotal)*100),1)\
| eval memused_PCT=round(((memused/memtotal)*100),1)\
| eval swapfree_PCT=round(((swapfree/swaptotal)*100),1)\
| eval swapused_PCT=round(((swapused/swaptotal)*100),1)\
| stats \
max(Real_total_MB) As Real_total_MB, max(Real_used_MB) As Real_used_MB,\
max(memtotal) As memtotal, max(memused) As memused,\
max(Virtual_total_MB) As Virtual_total_MB, max(Virtual_used_MB) As Virtual_used_MB, \
max(swaptotal) As swaptotal, max(swapused) As swapused\
max(Real_Free_PCT) As Real_Free_PCT,\
max(memfree_PCT) As memfree_PCT,\
max(Virtual_free_PCT) As Virtual_free_PCT,\
max(swapfree_PCT) As swapfree_PCT,\
max(Real_used_PCT) As Real_used_PCT,\
max(memused_PCT) As memused_PCT,\
max(Virtual_used_PCT) As Virtual_used_PCT,\
max(swapused_PCT) As swapused_PCT,\
max(buffers) As buffers, max(cached) As cached, max(inactive) As inactive\
by _time,hostname\
| eval Real_total_MB=if(isnotnull(Real_total_MB),Real_total_MB,memtotal)\
| eval Real_used_MB=if(isnotnull(Real_used_MB),Real_used_MB,memused)\
| eval Virtual_total_MB=if(isnotnull(Virtual_total_MB),Virtual_total_MB,swaptotal) \
| eval Virtual_used_MB=if(isnotnull(Virtual_used_MB),Virtual_used_MB,swapused)\
| eval Real_Free_PCT=if(isnotnull(Real_Free_PCT),Real_Free_PCT,memfree_PCT)\
| eval Virtual_free_PCT=if(isnotnull(Virtual_free_PCT),Virtual_free_PCT,swapfree_PCT)\
| eval Real_used_PCT=if(isnotnull(Real_used_PCT),Real_used_PCT,memused_PCT)\
| eval Virtual_used_PCT=if(isnotnull(Virtual_used_PCT),Virtual_used_PCT,swapused_PCT)
iseval = 0


###################################
# 	Prediction Manual Interact
###################################

[predict_manualinteract(2)]
args = selfperiod,selfvalue
definition = eval Predict=if(_time>if("$period$" == "now", now(),strptime("$period$", "%m/%d/%Y")),Predict+$selfvalue$,Predict)\
| eval low=if(_time>if("$period$" == "now", now(),strptime("$period$", "%m/%d/%Y")),low+$selfvalue$,low)\
| eval high=if(_time>if("$period$" == "now", now(),strptime("$period$", "%m/%d/%Y")),high+$selfvalue$,high)
iseval = 0


#################################################
#																#
#					NMON CONFIG SECTION					#
#																#
#################################################

# Rex common to all OS

[nmon_config_common_rex]
definition = rex "(?i),version,(?P<nmon_version>.+)"\
| rex "(?i),command,(?P<nmon_command>.+)"\
| rex "(?i),OS,(?P<OS>[^,]+)"\
| rex "AAA,cpus,(?P<cpu_cores_position1>\d+)"\
| rex "AAA,cpus,\d+,(?P<cpu_cores_position2>\d+)"
iseval = 0

# AIX Specific

[nmon_config_AIX_rex]
definition = rex "AAA,AIX,(?P<AIX_LEVEL>.+)"\
| rex "BBB.+,[0-9].+,lparstat.+,\"Online\sVirtual\sCPUs\s+\:\s(?P<AIX_virtualcpus>\d+)\""\
| rex "BBB.+,[0-9].+,online\sMemory,(?P<AIX_memory_MB>\d+)"\
| rex "BBB.+,[0-9].+,lsconf,\"\s+Total\sPaging\sSpace:\s(?P<AIX_pagingspace_MB>\d+)"\
| rex "BBB.+,[0-9].+,lsconf,\"Processor\sImplementation\sMode:\s(?P<AIX_processor_mode>.+\w)\""\
| rex "BBB.+,[0-9].+,lsconf,\"Processor\sClock\sSpeed:\s(?P<AIX_processor_clockspeed>.+\w)\""\
| rex "BBB.+,[0-9].+,lsconf,\"CPU\sType:\s(?P<AIX_cpu_type>.+\w)\""\
| rex "BBB.+,[0-9].+,lsconf,\"Kernel\sType:\s(?P<AIX_kernel_type>.+\w)\""\
| rex "BBB.+,[0-9].+,lsconf,\"Platform\sFirmware\slevel:\s(?P<AIX_plateform_firmware_level>.+\w)\""\
| rex "BBB.+,[0-9].+,lsconf,\"Machine\sSerial\sNumber:\s(?P<AIX_Machine_SerialNumber>.+)\""\
| rex "AAA,SerialNumber,(?P<AIX_alt_Machine_SerialNumber>\w+)"\
| eval AIX_Machine_SerialNumber=if(isnotnull(AIX_Machine_SerialNumber), AIX_Machine_SerialNumber, AIX_alt_Machine_SerialNumber)\
| rex "BBB.+,[0-9].+,lparstat.+,\"Shared\sPool\sID\s+\:\s(?P<AIX_PoolID>.+)\""\
| eval AIX_PoolID=if(AIX_PoolID=="-","N/A" ,AIX_PoolID)\
| rex "BBB.+,[0-9].+,lparstat.+,\"Maximum\sPhysical\sCPUs\sin\ssystem\s+\:\s(?P<AIX_system_installed_CPUs>.+)\""\
| rex "BBB.+,[0-9].+,lparstat.+,\"Active\sPhysical\sCPUs\sin\ssystem\s+\:\s(?P<AIX_system_active_CPUs>.+)\""\
| rex "BBB.+,[0-9].+,lparstat.+,\"Active\sCPUs\sin\sPool\s+\:\s(?P<AIX_PoolCPUs>.+)\""\
| eval AIX_PoolCPUs=if(AIX_PoolCPUs=="-","N/A" ,AIX_PoolCPUs)\
| rex "BBB.+,[0-9].+,lparstat.+,\"Entitled\sCapacity\s+\:\s(?P<AIX_entitled>.+)\""\
| rex "BBB.+,[0-9].+,lsconf,\"Processor\sType:\s(?P<AIX_processor>.+\w)\""\
| strcat AIX_virtualcpus " / " cpu_cores_position2 cpu_cores_combo\
| eval AIX_logicalcores=if(isnotnull(cpu_cores_position2), cpu_cores_position2, cpu_cores_position1)
iseval = 0

# Linux specific

[nmon_config_Linux_rex]
definition = rex "AAA,OS,Linux,(?P<Linux_LEVEL>.+)"\
| rex "BBB.+,[0-9].+cpuinfo,.+model\sname.+:\s+(?P<Linux_processor>.+)\""\
| rex "BBB.+,[0-9].+,.+etc+.release,\"(?P<Linux_distribution>.+)\""\
| rex "BBB.+,[0-9].+,lsb\_release,\"Release:\s+(?P<Linux_version>.+)\""\
| rex "BBB.+,[0-9].+,.proc.meminfo,\"MemTotal:\s+(?P<Linux_memory_kB>\d+)" | eval Linux_memory_MB=round(Linux_memory_kB/1024,0)\
| rex "BBB.+,[0-9].+,.proc.meminfo,\"SwapTotal:\s+(?P<Linux_swap_kB>\d+)" | eval Linux_swap_MB=round(Linux_swap_kB/1024,0)\
| rex "AAA,OS,Linux,(?P<Linux_kernelversion>\d+.\d+).+,#"\
| rex "AAA,OS,Linux,(?P<Linux_kernel>.+),#"\
| rex "AAA,OS,Linux,(?P<Linux_fullkernel>.+)"
iseval = 0

# Solaris specific

[nmon_config_Solaris_rex]
definition = rex "AAA,OS,Solaris,(?P<Solaris_LEVEL>.+)"\
| rex "AAA,OS,Solaris,.+,(?P<Solaris_kernel>.+),.+,.+"\
| rex "AAA,OS,Solaris,(?P<Solaris_sunOS_version>.+),.+,.+,.+"\
| rex "BBB.+,[0-9].+,.+etc+.release,\"\s+(?P<Solaris_version>.+)\""\
| rex "BBB.+,[0-9].+psrinfo\s\-pv,\"\s+(?P<Solaris_processor>.+\w)\""\
| rex "BBB.+,[0-9].+psrinfo\s\-pv,.+clock\s(?P<Solaris_processor_clockspeed>.+)\)\""
iseval = 0



###################################
# 	Final macros used for inventory data retrieve
###################################

[nmon_config]
definition = index=nmon sourcetype=nmon_config\
| rex "(?i),host,(?P<hostname>.+)"\
| `nmon_config_common_rex`\
| `nmon_config_AIX_rex`\
| `nmon_config_Linux_rex`\
| `nmon_config_Solaris_rex`\
| eval OStype=case(OS == "Linux", "Linux", OS == "Solaris", "Solaris", isnotnull(AIX_LEVEL), "AIX")\
| eval OS_Level=case(isnotnull(AIX_LEVEL), AIX_LEVEL, isnotnull(Solaris_version), Solaris_version, isnotnull(Linux_distribution), Linux_distribution)\
| eval cpu_cores=if(isnotnull(AIX_virtualcpus), cpu_cores_combo, cpu_cores_position1)\
| eval Processor=case(isnotnull(AIX_processor), AIX_processor, isnotnull(Solaris_processor), Solaris_processor, isnotnull(Linux_processor), Linux_processor)
iseval = 0



# Used in addition with the command: index=nmon sourcetype=nmon_config | rex "(?i),host,(?<hostname>.+)" | search $hostname$" in Nmon_Summary
# to optimize time treatment

[nmon_config_rex]
definition = `nmon_config_common_rex`\
| `nmon_config_AIX_rex`\
| `nmon_config_Linux_rex`\
| `nmon_config_Solaris_rex`\
| eval OStype=case(OS == "Linux", "Linux", OS == "Solaris", "Solaris", isnotnull(AIX_LEVEL), "AIX")\
| eval OS_Level=case(isnotnull(AIX_LEVEL), AIX_LEVEL, isnotnull(Solaris_version), Solaris_version, isnotnull(Linux_distribution), Linux_distribution)\
| eval cpu_cores=if(isnotnull(AIX_virtualcpus), cpu_cores_combo, cpu_cores_position1)\
| eval Processor=case(isnotnull(AIX_processor), AIX_processor, isnotnull(Solaris_processor), Solaris_processor, isnotnull(Linux_processor), Linux_processor)
iseval = 0


# Called by User Interfaces to filter OS list based on type of OS

[nmon_inventory]
definition = | inputlookup nmon_inventory
iseval = 0


###################################
# 	Custom Span definition for Application Statistics Django View
###################################

[internal_table_stats_span]
definition = [ search index=_internal | head 1 | addinfo\
| eval earliest=if(info_min_time == "0.000", info_search_time,info_min_time)\
| eval latest=if(info_max_time == "+Infinity", info_search_time,info_max_time)\
| eval searchStartTIme=strftime(earliest,"%a %d %B %Y %H:%M")\
| eval searchEndTime=strftime(latest,"%a %d %B %Y %H:%M")\
| eval Difference = (latest - earliest)\
| eval span=case(\
Difference > (12*31*24*60*60),"1y",\
Difference > (31*24*60*60),"1m",\
Difference > (24*60*60),"1d",\
Difference <= (24*60*60),"1h"\
)\
| return span ]
iseval = 0


#####################
#	FILTER TIME		#
#####################

[No_Filter]
definition = eval local_time=strftime(_time, "%H:%M")
iseval = 0

[Day_BusinessDays_8h-19h]
definition = eval local_time=strftime(_time, "%H:%M") | search (local_time>="08:00" AND local_time<="19:00") AND (date_wday!="sunday" date_wday!="saturday")
iseval = 0

[Day_WeekEnd_8h-19h]
definition = eval local_time=strftime(_time, "%H:%M") | search (local_time>="08:00" AND local_time<="19:00") AND (date_wday="sunday" OR date_wday="saturday")
iseval = 0

[Day_AllDays_8h-19h]
definition = eval local_time=strftime(_time, "%H:%M") | search (local_time>="08:00" AND local_time<="19:00")
iseval = 0

[Night_BusinessDays_19h-8h]
definition = eval local_time=strftime(_time, "%H:%M") | search (local_time>="19:00" AND local_time<="23:59") OR (local_time>="00:00" AND local_time<="08:00") AND (date_wday!="sunday" date_wday!="saturday")
iseval = 0

[Night_WeekEnd_19h-8h]
definition = eval local_time=strftime(_time, "%H:%M") | search (local_time>="19:00" AND local_time<="23:59") OR (local_time>="00:00" AND local_time<="08:00") AND (date_wday="sunday" OR date_wday="saturday")
iseval = 0

[Night_AllDays_19h-8h]
definition = eval local_time=strftime(_time, "%H:%M") | search (local_time>="19:00" AND local_time<="23:59") OR (local_time>="00:00" AND local_time<="08:00")
iseval = 0

# Data Model Macros

[No_Filter(1)]
args = datamodel
definition =($datamodel$.date_wday=*) ($datamodel$.local_time=*)
iseval = 0

[Day_BusinessDays_8h-19h(1)]
args = datamodel
definition = ($datamodel$.date_wday!=saturday AND $datamodel$.date_wday!=sunday) ($datamodel$.local_time>=0800 AND $datamodel$.local_time<=1900)
iseval = 0

[Day_WeekEnd_8h-19h(1)]
args = datamodel
definition = ($datamodel$.date_wday=saturday OR $datamodel$.date_wday=sunday) ($datamodel$.local_time>=0800 AND $datamodel$.local_time<=1900)
iseval = 0

[Day_AllDays_8h-19h(1)]
args = datamodel
definition = ($datamodel$.date_wday=*) ($datamodel$.local_time>=0800 AND $datamodel$.local_time<=1900)
iseval = 0

[Night_BusinessDays_19h-8h(1)]
args = datamodel
definition = ($datamodel$.date_wday!=saturday AND $datamodel$.date_wday!=sunday) ($datamodel$.local_time>=1900 OR $datamodel$.local_time<=0800)
iseval = 0

[Night_WeekEnd_19h-8h(1)]
args = datamodel
definition = ($datamodel$.date_wday=saturday OR $datamodel$.date_wday=sunday) ($datamodel$.local_time>=1900 OR $datamodel$.local_time<=0800)
iseval = 0

[Night_AllDays_19h-8h(1)]
args = datamodel
definition = ($datamodel$.date_wday=*) ($datamodel$.local_time>=1900 OR $datamodel$.local_time<=0800)
iseval = 0

####################################################
#																	#
#					NMON PROCESSING SECTION					#
#																	#
####################################################

[nmon_processing]
definition = index=nmon sourcetype=nmon_processing
iseval = 0

[nmon_processing_stats]
definition = `nmon_processing`\
| eval size_KB=round((size_in_bytes/1000),2)\
| eval size_MB=round((size_in_bytes/1000/1000),2)\
| stats\
min(nbr_lines) As min_nbr_lines, avg(nbr_lines) As avg_nbr_lines, max(nbr_lines) As max_nbr_lines, sum(nbr_lines) As sum_nbr_lines,\
min(size_KB) As min_size_KB, avg(size_KB) As avg_size_KB, max(size_KB) As max_size_KB, sum(size_KB) As sum_size_KB,\
min(size_MB) As min_size_MB, avg(size_MB) As avg_size_MB, max(size_MB) As max_size_MB, sum(size_MB) As sum_size_MB,\
min(elapsed_in_seconds) As min_elapsed_in_seconds, avg(elapsed_in_seconds) As avg_elapsed_in_seconds, max(elapsed_in_seconds) As max_elapsed_in_seconds, sum(elapsed_in_seconds) As sum_elapsed_in_seconds\
| eval sum_nbr_lines_in_millions=round((sum_nbr_lines/1000/1000),2)\
| eval sum_size_GB=round((sum_size_KB/1000/1000),2)\
| eval sum_elapsed=tostring(sum_elapsed_in_seconds,"duration")\
| eval avg_nbr_lines=round(avg_nbr_lines,0)\
| eval avg_size_MB=round(avg_size_MB,2)\
| eval avg_elapsed_in_seconds=round(avg_elapsed_in_seconds,2)
iseval = 0

[nmon_processing_stats_by_time]
definition = `nmon_processing`\
| eval size_KB=round((size_in_bytes/1000),2)\
| eval size_MB=round((size_in_bytes/1000/1000),2)\
| stats\
min(nbr_lines) As min_nbr_lines, avg(nbr_lines) As avg_nbr_lines, max(nbr_lines) As max_nbr_lines, sum(nbr_lines) As sum_nbr_lines,\
min(size_KB) As min_size_KB, avg(size_KB) As avg_size_KB, max(size_KB) As max_size_KB, sum(size_KB) As sum_size_KB,\
min(size_MB) As min_size_MB, avg(size_MB) As avg_size_MB, max(size_MB) As max_size_MB, sum(size_MB) As sum_size_MB,\
min(elapsed_in_seconds) As min_elapsed_in_seconds, avg(elapsed_in_seconds) As avg_elapsed_in_seconds, max(elapsed_in_seconds) As max_elapsed_in_seconds, sum(elapsed_in_seconds) As sum_elapsed_in_seconds by _time\
| eval sum_nbr_lines_in_millions=round((sum_nbr_lines/1000/1000),2)\
| eval sum_size_GB=round((sum_size_KB/1000/1000),2)\
| eval avg_nbr_lines=round(avg_nbr_lines,0)\
| eval avg_size_MB=round(avg_size_MB,2)\
| eval avg_elapsed_in_seconds=round(avg_elapsed_in_seconds,2)
iseval = 0


####################################################
#																	#
#		macros used in views with tstats					#
#																	#
####################################################

# these macro will reduce the code length for the use of Data model tstats search in views

[CPU_ALL(1)]
args = statsmode
definition = $statsmode$("CPU.cpu_PCT") AS CPU.cpu_PCT,\
$statsmode$("CPU.Idle_PCT") AS CPU.Idle_PCT,\
$statsmode$("CPU.Sys_PCT") AS CPU.Sys_PCT,\
$statsmode$("CPU.User_PCT") AS CPU.User_PCT,\
$statsmode$("CPU.Wait_PCT") AS CPU.Wait_PCT
iseval = 0

[CPU_ALL_rename]
definition = rename CPU.cpu_PCT AS "CPU %", CPU.Idle_PCT AS "Idle %", CPU.Sys_PCT AS "Sys %", CPU.User_PCT AS "User %", CPU.Wait_PCT AS "Wait %"
iseval = 0

[LPAR(1)]
args = statsmode
definition = $statsmode$("CPU.lpar_vp_usage") AS CPU.lpar_vp_usage,\
$statsmode$("CPU.LPAR.lpar_vp_PCT_usage") AS CPU.LPAR.lpar_vp_PCT_usage,\
$statsmode$("CPU.LPAR.lpar_ec_usage") AS CPU.LPAR.lpar_ec_usage,\
$statsmode$("CPU.LPAR.lpar_ec_Pct_usage") AS CPU.LPAR.lpar_ec_Pct_usage,\
max("CPU.entitled") AS CPU.entitled,\
max("CPU.virtualCPUs") AS CPU.virtualCPUs
iseval = 0

[LPAR_rename]
definition = rename CPU.lpar_vp_usage AS "VP usage", CPU.LPAR.lpar_vp_PCT_usage AS "VP % usage", CPU.LPAR.lpar_ec_usage AS "EC usage", CPU.LPAR.lpar_ec_Pct_usage AS "EC % usage", CPU.entitled AS "Entitled", CPU.virtual_cpus AS "Virtual CPUs"
iseval = 0

[NFSSVRV4(1)]
args = statsmode
definition = $statsmode$(NFS.op0-unused),$statsmode$(NFS.op1-unused),$statsmode$(NFS.op2-future),$statsmode$(NFS.access),$statsmode$(NFS.close),$statsmode$(NFS.commit),$statsmode$(NFS.create),\
$statsmode$(NFS.delegpurge),$statsmode$(NFS.delegreturn),$statsmode$(NFS.getattr),$statsmode$(NFS.getfh),$statsmode$(NFS.link),$statsmode$(NFS.lock),$statsmode$(NFS.lockt),\
$statsmode$(NFS.locku),$statsmode$(NFS.lookup),$statsmode$(NFS.lookup_root),$statsmode$(NFS.nverify),$statsmode$(NFS.open),$statsmode$(NFS.openattr),$statsmode$(NFS.open_conf),\
$statsmode$(NFS.open_dgrd),$statsmode$(NFS.putfh),$statsmode$(NFS.putpubfh),$statsmode$(NFS.putrootfh),$statsmode$(NFS.read),$statsmode$(NFS.readdir),$statsmode$(NFS.readlink),\
$statsmode$(NFS.remove),$statsmode$(NFS.rename),$statsmode$(NFS.renew),$statsmode$(NFS.restorefh),$statsmode$(NFS.savefh),$statsmode$(NFS.secinfo),$statsmode$(NFS.setattr),\
$statsmode$(NFS.setcltid),$statsmode$(NFS.setcltidconf),$statsmode$(NFS.verify),$statsmode$(NFS.write),$statsmode$(NFS.rellockowner)
iseval = 0

[NFSSVRV3(1)]
args = statsmode
definition = $statsmode$(NFS.null),$statsmode$(NFS.getattr),$statsmode$(NFS.setattr),$statsmode$(NFS.lookup),$statsmode$(NFS.access),\
$statsmode$(NFS.readlink),$statsmode$(NFS.read),$statsmode$(NFS.write),$statsmode$(NFS.create),$statsmode$(NFS.mkdir),$statsmode$(NFS.symlink),\
$statsmode$(NFS.mknod),$statsmode$(NFS.remove),$statsmode$(NFS.rmdir),$statsmode$(NFS.rename),$statsmode$(NFS.link),$statsmode$(NFS.readdir),\
$statsmode$(NFS.readdirplus),$statsmode$(NFS.fsstat),$statsmode$(NFS.fsinfo),$statsmode$(NFS.pathconf),$statsmode$(NFS.commit)
iseval = 0

[NFSSVRV2(1)]
args = statsmode
definition = $statsmode$(NFS.null),$statsmode$(NFS.getattr),$statsmode$(NFS.setattr),$statsmode$(NFS.root),$statsmode$(NFS.lookup),$statsmode$(NFS.readlink),\
$statsmode$(NFS.read),$statsmode$(NFS.wrcache),$statsmode$(NFS.write),$statsmode$(NFS.create),$statsmode$(NFS.remove),$statsmode$(NFS.rename),$statsmode$(NFS.link),\
$statsmode$(NFS.symlink),$statsmode$(NFS.mkdir),$statsmode$(NFS.rmdir),$statsmode$(NFS.readdir),$statsmode$(NFS.fsstat)
iseval = 0

[NFSCLIV4(1)]
args = statsmode
definition = $statsmode$(NFS.null),$statsmode$(NFS.read),$statsmode$(NFS.write),$statsmode$(NFS.commit),$statsmode$(NFS.open),$statsmode$(NFS.open_conf),$statsmode$(NFS.open_noat),\
$statsmode$(NFS.open_dgrd),$statsmode$(NFS.close),$statsmode$(NFS.setattr),$statsmode$(NFS.fsinfo),$statsmode$(NFS.renew),$statsmode$(NFS.setclntid),\
$statsmode$(NFS.confirm),$statsmode$(NFS.lock),$statsmode$(NFS.lockt),$statsmode$(NFS.locku),$statsmode$(NFS.access),$statsmode$(NFS.getattr),$statsmode$(NFS.lookup),\
$statsmode$(NFS.lookup_root),$statsmode$(NFS.remove),$statsmode$(NFS.rename),$statsmode$(NFS.link),$statsmode$(NFS.symlink),$statsmode$(NFS.create),$statsmode$(NFS.pathconf),\
$statsmode$(NFS.statfs),$statsmode$(NFS.readlink),$statsmode$(NFS.readdir),$statsmode$(NFS.server_caps),$statsmode$(NFS.delegreturn),$statsmode$(NFS.getacl),$statsmode$(NFS.setacl),
$statsmode$(NFS.fs_locations)
iseval = 0

[NFSCLIV3(1)]
args = statsmode
definition = $statsmode$(NFS.null),$statsmode$(NFS.getattr),$statsmode$(NFS.setattr),$statsmode$(NFS.lookup),$statsmode$(NFS.access),$statsmode$(NFS.readlink),$statsmode$(NFS.read),\
$statsmode$(NFS.write),$statsmode$(NFS.create),$statsmode$(NFS.mkdir),$statsmode$(NFS.symlink),$statsmode$(NFS.mknod),$statsmode$(NFS.remove),$statsmode$(NFS.rmdir),\
$statsmode$(NFS.rename),$statsmode$(NFS.link),$statsmode$(NFS.readdir),$statsmode$(NFS.readdirplus),$statsmode$(NFS.fsstat),$statsmode$(NFS.fsinfo),$statsmode$(NFS.pathconf),\
$statsmode$(NFS.commit)
iseval = 0

[NFSCLIV2(1)]
args = statsmode
definition = $statsmode$(NFS.null),$statsmode$(NFS.getattr),$statsmode$(NFS.setattr),$statsmode$(NFS.root),$statsmode$(NFS.lookup),$statsmode$(NFS.readlink),$statsmode$(NFS.read),\
$statsmode$(NFS.wrcache),$statsmode$(NFS.write),$statsmode$(NFS.create),$statsmode$(NFS.remove),$statsmode$(NFS.rename),$statsmode$(NFS.link),\
$statsmode$(NFS.symlink),$statsmode$(NFS.mkdir),$statsmode$(NFS.rmdir),$statsmode$(NFS.readdir),$statsmode$(NFS.fsstat)
iseval = 0

####################################################
#																	#
#		macros used in dashboards with tstats			#
#																	#
####################################################

[CPU_ALL(5)]
args = statsmode,frameID,OStype,hostname,timefilter
definition = max(CPU.cpu_PCT) AS cpu_PCT from datamodel=NMON_Data_CPU\
where (nodename = CPU.CPU_ALL) (CPU.frameID=$frameID$) (CPU.OStype=$OStype$) (CPU.hostname=$hostname$) `$timefilter$(CPU)` groupby _time, "CPU.frameID", "CPU.hostname" prestats=true\
| stats dedup_splitvals=t max(CPU.cpu_PCT) AS cpu_PCT by _time, "CPU.frameID", "CPU.hostname"\
| stats $statsmode$(cpu_PCT) AS usage by "CPU.frameID", "CPU.hostname" | rename "CPU.frameID" AS frameID "CPU.hostname" AS hostname
iseval = 0

[LPAR_usage(5)]
args = statsmode,frameID,OStype,hostname,timefilter
definition = max("CPU.lpar_vp_usage") AS lpar_vp_usage, max("CPU.LPAR.lpar_vp_PCT_usage") AS lpar_vp_PCT_usage, max("CPU.entitled") AS entitled, max("CPU.virtualCPUs") AS virtualCPUs\
from datamodel=NMON_Data_CPU where (nodename = CPU.LPAR) (CPU.OStype=$OStype$) (CPU.hostname=$hostname$) (CPU.frameID=$frameID$) `$timefilter$(CPU)` groupby _time,"CPU.frameID","CPU.hostname" prestats=true\
| stats max("CPU.lpar_vp_usage") AS lpar_vp_usage, max("CPU.LPAR.lpar_vp_PCT_usage") AS lpar_vp_PCT_usage, max("CPU.entitled") AS entitled, max("CPU.virtualCPUs") AS virtualCPUs by _time,"CPU.frameID","CPU.hostname"\
| stats $statsmode$("lpar_vp_usage") AS usage, $statsmode$("lpar_vp_PCT_usage") AS usage_PCT, max("entitled") AS entitled, max("virtualCPUs") AS virtualCPUs by "CPU.frameID","CPU.hostname" | rename "CPU.frameID" AS frameID, "CPU.hostname" AS hostname
iseval = 0

[LPAR_poolusage(5)]
args = statsmode,frameID,OStype,hostname,timefilter
definition = max("CPU.LPAR.Pool_usage") AS Pool_usage, max("CPU.LPAR.Pool_PCT_usage") AS Pool_PCT_usage, max("CPU.LPAR.poolCPUs") AS poolCPUs\
from datamodel=NMON_Data_CPU where (nodename = CPU.LPAR) (CPU.PoolIdle>0) (CPU.LPAR.Pool_id=0) (CPU.OStype=$OStype$) (CPU.hostname=$hostname$) (CPU.frameID=$frameID$) `$timefilter$(CPU)` groupby _time,"CPU.frameID","CPU.hostname" prestats=true\
| stats max("CPU.LPAR.Pool_usage") AS Pool_usage, max("CPU.LPAR.Pool_PCT_usage") AS Pool_PCT_usage, max("CPU.LPAR.poolCPUs") AS poolCPUs by _time,"CPU.frameID","CPU.hostname"\
| search (Pool_usage!=poolCPUs)\
| stats $statsmode$("Pool_usage") AS usage, $statsmode$("Pool_PCT_usage") AS usage_PCT, max("poolCPUs") AS poolCPUs by "CPU.frameID","CPU.hostname" | rename "CPU.frameID" AS frameID, "CPU.hostname" AS hostname\
| sort - usage | dedup frameID
iseval = 0

[MEM(5)]
args = statsmode,frameID,OStype,hostname,timefilter
definition = max("MEM.allOS_Real_Free_PCT") AS allOS_Real_Free_PCT max("MEM.allOS_Real_total_MB") AS allOS_Real_total_MB max("MEM.allOS_Real_used_MB") AS allOS_Real_used_MB\
max("MEM.allOS_Real_used_PCT") AS allOS_Real_used_PCT max("MEM.allOS_Virtual_free_PCT") AS allOS_Virtual_free_PCT max("MEM.allOS_Virtual_total_MB") AS allOS_Virtual_total_MB\
max("MEM.allOS_Virtual_used_MB") AS allOS_Virtual_used_MB max("MEM.allOS_Virtual_used_PCT") AS allOS_Virtual_used_PCT from datamodel=NMON_Data_MEM\
where (nodename = MEM) (MEM.OStype=$OStype$) (MEM.hostname=$hostname$) (MEM.frameID=$frameID$)\
groupby _time, "MEM.frameID", "MEM.hostname" prestats=true\
| stats dedup_splitvals=t max("MEM.allOS_Real_Free_PCT") AS allOS_Real_Free_PCT max("MEM.allOS_Real_total_MB") AS allOS_Real_total_MB max("MEM.allOS_Real_used_MB") AS allOS_Real_used_MB\
max("MEM.allOS_Real_used_PCT") AS allOS_Real_used_PCT max("MEM.allOS_Virtual_free_PCT") AS allOS_Virtual_free_PCT max("MEM.allOS_Virtual_total_MB") AS allOS_Virtual_total_MB\
max("MEM.allOS_Virtual_used_MB") AS allOS_Virtual_used_MB max("MEM.allOS_Virtual_used_PCT") AS allOS_Virtual_used_PCT by _time, "MEM.frameID", "MEM.hostname"\
| stats dedup_splitvals=t $statsmode$("allOS_Real_Free_PCT") AS Real_Free_PCT $statsmode$("allOS_Real_total_MB") AS Real_total_MB $statsmode$("allOS_Real_used_MB") AS Real_used_MB\
$statsmode$("allOS_Real_used_PCT") AS Real_used_PCT $statsmode$("allOS_Virtual_free_PCT") AS Virtual_free_PCT $statsmode$("allOS_Virtual_total_MB") AS Virtual_total_MB\
$statsmode$("allOS_Virtual_used_MB") AS Virtual_used_MB $statsmode$("allOS_Virtual_used_PCT") AS Virtual_used_PCT by "MEM.frameID", "MEM.hostname"\
| rename "MEM.frameID" AS "frameID" "MEM.hostname" AS hostname
iseval = 0






